#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
@created: Wed Jul  4 21:10:50 2018

@author: Thomas Pluck

@lastedit: Fri Jul  6 00:10:00 2018
"""

import numpy as np
from repetend import no_repet, look

#Takes arguements of 4-tuples parameterizing
#mobius transforms and performs calculations
#for easy application

class MoebiusTransform:
    
    def __init__(self,param):
        #Allow input of parameter tuple or numpy array
        if type(param) == tuple:
            a,b,c,d = param[0],param[1],param[2],param[3]
        
            self.array = np.array([[a,b],
                                   [c,d]])
            self.inv = np.inv(self.array)
        elif type(param) == np.ndarray:
            self.array = param
            a,b,c,d = param[0,0],param[0,1],param[1,0],param[1,1]
        else:
            raise TypeError("MoebiusTransform must be defined with either a 2 by 2 numpy ndarray or a 4-tuple")
        #Calculate fixed points
        if c!= 0+0j:
            self.fixed_points = [((a-d)+((a-d)**2+(4*b*c))**0.5)/(2*c),
                                 ((a-d)-((a-d)**2+(4*b*c))**0.5)/(2*c)]
        else:
            if a != d:
                self.fixed_points = [float('inf'),-b/(a-d)]
            elif b == 0+0j:
                self.fixed_points = [float('inf'),0]
            else:
                self.fixed_points = [float('inf'),float('inf')]

        #Classify points as either sinks or sources
        self.sink,self.source = None,None

        #Test stationary points for either being a sink or a source
        delt = 1e-11
        n = 24
        ref = [np.exp(0+1j*i*np.pi/n) for i in range(n)]
        eps = []
        for p in self.fixed_points:
            if p != float('inf'):
                for r in ref:
                    eps.append(abs(((self.array[0,0]*(p+delt*r)+self.array[0,1])/\
                               (self.array[1,0]*(p+delt*r)+self.array[1,1]))-p))
            
    
            if all(e>delt for e in eps):
                if self.sink == None:
                    self.sink = p
            elif all(e<delt for e in eps):
                if self.sink == None:
                    self.source = p
            eps = []
        
        if self.sink != None and self.source == None:
            try:
                self.source = [s for s in self.fixed_points if s != self.sink][0]
            except:
                self.source = self.sink
        if self.source != None and self.sink == None:
            try:
                self.sink = [s for s in self.fixed_points if s != self.source][0]
            except:
                self.sink = self.source
        
        #Classify transform
        
        trace = np.trace(self.array)**2
        w,v = np.linalg.eig(self.array)
        
        if trace == 0:
            self.kind = "Circular"
        elif trace < 4 and trace >= 0 and w[0]**2 == -1:
            self.kind = "Elliptic"
        elif trace == 4 and w[0] == 1:
            self.kind = "Parabolic"
        elif trace > 4 and w[0].real > 0 and not np.iscomplex(w[0]):
            self.kind = "Hyperbolic"
        elif (trace < 0 or trace > 4) and abs(w[0]) != 1:
            self.kind = "Loxodromic"
        else:
            self.kind = "Unclassified"
          
    #Transform a complex number with the transform

    def __repr__(self):        
        return str(self.array)
    
    def __str__(self):
        return str(self.array)
    
    def transform(self,num):
        return (self.array[0,0]*num+self.array[0,1])/(self.array[1,0]*num+self.array[1,1])
    
    def inv_transform(self,num):
        return (self.inv[0,0]*num+self.inv[0,1])/(self.inv[1,0]*num+self.inv[1,1])

#Simple function to compose two mobius transforms
def mob_mul(mob_1,mob_2):
    return MoebiusTransform(np.matmul(mob_1.array,mob_2.array))

#Semigroup object which takes a single arguement of a list of
#MoebiusTransforms. Onboard applications include limitset
#calculation and orbit calculation

class SemiGroup:
    
    def __init__(self,generators):
        
        if not all(type(g.array) == np.ndarray for g in generators)\
        or not type(generators)==list:
            raise TypeError('input must be a list of MoebiusTransform objects')

        self.generators = {str(idx)+',':v for idx,v in enumerate(generators)}
        self.repetends = {}
        self.extensions = {}
        
        self.limit_set = []
        self.orbits = []
        
    def __repr__(self):
        return "Semigroup generated by:\n"+str(self.generators)\
    
    def __str__(self):
        return "Semigroup generated by:\n"+str(self.generators)
    
    def compute_limits(self,depth):
        self.repetends.update(self.generators)
        for d in range(depth):
            for key1,val1 in self.generators.iteritems():
                for key2,val2 in self.repetends.iteritems():
                    if no_repet(key1+key2) and look(self.repetends.keys(),key1+key2):
                        self.repetends.update({key1+key2:mob_mul(val1,val2)})
        self.limit_set = [r.sink for k,r in self.repetends.iteritems() if r.sink != float('inf') and r.sink != None]
        self.limit_set += [r.inv_transform(s) for s in self.limit_set for r in self.repetends.values()]
 
    def compute_orbit(depth,top_left_x,top_left_y,bot_right_x,bot_right_y):
        return False
